fn main() {
    //1.参数
    //我们可以定义为拥有参数（parameters）的函数，参数是特殊变量，是函数签名的一部分。当函数拥有参数（形参）时，可以为这些参数提供具体的值（实参）。技术上讲，这些具体值被称为参数(arguemnts)，但是在日常交流中，人们倾向于不区分使用parameter和argument来表示函数定义中的变量或者调用函数时传入的具体值。
    another_function!(32);
    /*
    2.语句和表达式
    函数体由一系列的语句和一个可选的结尾表达式构成。rust是一门基于表达式(expression-based)的语言，这是一个需要理解的（不同于其他语言）重要区别。其他语言并没有这样的区别，所以让我们看看语句与表达式有什么区别以及这个区别是如何影响函数体的。
    语句（statements）是执行一些操作但不返回值的指令。表达式（Expressions）计算并产生一个值。
    let y = 6;就是一个语句，函数定义也是语句。
    语句不返回值，因此，不能把let语句赋值给另一个变量。
    let x = (let y = 6);
    let y = 6 语句并不返回值，所以没有可以绑定到x上的值。这与其他语言不同，例如C和Ruby，他们的赋值语句会返回所赋的值。在这些语言中可以这么写x = y = 6，这样x和y的值都是6；rust则不能这么写。
    表达式会计算出一个值，并且你将编写的大部分rust代码是由表达式组成的。考虑一个数学运算，比如5+6，这是一个表达式并计算出值11。
    表达式可以是语句的一部分：语句let y = 6;中的6是一个表达式，它计算出的值是6。
    函数调用是一个表达式。宏调用是一个表达式。
    用大括号创建的一个新的块作用域也是一个表达式，例如：
    `fn main() {
        let y = {
            let x = 3;
            x + 1
        }
        println!("The value of y is: {}", y);
    }`
    这个表达式{let x = 3; x + 1}是一个代码块，它的值是4。这个值作为let语句的一部分被绑定到y上。注意x+1这一行在结尾没有分号，与你见过的大部分代码行不同。表达式的结尾没有分号。如果在表达式的结尾加上分号，他就变成了语句，而语句是没有返回值的。
    */
    let y = 6;
    let y = {
        let x = 3;
        x + 1
    }
    println!("The value of y is: {}", y);//4
    /*
    3.具有返回值的函数
    函数可以向调用它的代码返回值。我们并不对返回值命名，但要在箭头(->)后声明它的类型。
    在rust中，函数的返回值等同于函数体最后一个表达式的值。使用return关键字和指定值，可以从函数中提前返回；但大部分函数隐式的返回最后的表达式。
    */
    let x = five();
    println!("The value of x is: {}", x);//5
}

fn five() -> i32 {
    5
}

/*
another_function的声明中有一个命名为x的参数。x的类型被指定为i32。当我们将5传给another_function时，println!宏将5放入格式化字符串中大括号的位置。
在函数签名中，必须声明每个参数的类型。rust要求在函数定义中提供类型注解，意味着编译器再也不需要你在代码的其他地方注明类型来指出你的意图。
*/
fn another_function(x: i32) {
    println!("The value of x is: {}", x);
}
